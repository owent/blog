libcopp(协程)的共享栈模型实现
============

[libcopp][1]是以前写得现在几个项目都在用的跨平台C++协程库。

本来我是不打算实现这个feature的，因为是这个feature会带来很多使用上的限制条件。但是前段时间看到知乎里好多人讨论微信的[libco][2]的共享栈实现。仔细想了一下，可能还是由一些应用场景。

什么是共享栈？
------
传统的协程（也就是[libcopp][1]的目前的实现）是创建一个栈，用于执行时的栈开销，创建一个上下文对象用于保存各种寄存器信息。然后协程切换的时候做得事情是恢复寄存器和改掉栈的基址（SP寄存器）。

对于不同的环境都有一些不太一样的方法，比如POSIX定义的makecontext/swapcontext（微信的[libco][2]就是用了这个）。VC++有Fiber API。然后[libcopp][1]是fork了boost.context改得。

然而这有一个问题，就是你必须先分配出用于执行的执行栈。比如现在很多环境默认栈大小都是8MB，那么如果你分配1000个协程，岂不是要8GB？并且其实大多数情况下，你会用到的执行栈甚至不会大于100KB。
这样就导致了大量的内存浪费。当然现在的内存分配器并不是你用了内存就立刻会映射物理内存给你，而是用到才会给，但是只要用到一次，如果你把这个内存缓存起来了，也会导致浪费的空间越来越大。

对于托管式语言而言，处理这个问题并不困难，可以先分配比较小的栈，然后不够的时候拼接起来，或者重新分配栈并且调整下引用数据的位置就好了。
而Go语言发明了Goroutine，其实也是采用了类似托管式语言的做法，RunTime做内存管理，并不向外暴露原始地址。
但是C/C++不能这样，因为可能会把栈上数据的地址传出去。
目前的解决方法一种是减小分配的栈长度，比如我们之前项目的coroutine的栈分配都是只有512KB，但是其实还是有比较大的浪费。
另一种是用gcc的split-segment的动态栈特性。但是这个特性据说是性能不太好（[libcopp][1]支持但是我没在生产环境使用过，看它的实现方式我觉得有点坑，具体原因在之前介绍[libcopp][1]的时候提过了）。
而且gcc动态栈的话也受平台限制（linux+gcc才行）。

所以另一种解决方案就是这个共享栈。简单地说就是切出协程的时候把用到的栈数据copy到另一个地方，切入的时候先copy过来再把寄存器切过来。
这样的话切出以后保存的栈的数据就是按真实使用的栈的量来copy的，只是要多耗费一次memcpy。

为什么之前没考虑实现？
------
[libcopp][1]使用的是boost.context。效率比较高，一次即便是mmap创建协程+初始化执行栈的消耗大约是8us。而一次协程切入切出的消耗仅在400ns。（具体见：https://github.com/owt5008137/libcopp/blob/master/doc/reports/linux_benchmark_report.txt）

共享栈的话，memcpy其实量比较多，并且每次切换还涉及一次malloc和free，会比较耗费CPU。

后来稍微算了一下，实际上即便用到了64KB的栈空间，按现代的内存速度，一次memcpy也只需要大约10us。如果一个协程并不是老做切出切入操作，并且栈不深，这个CPU消耗还是可以接受的。

结合我们之前项目的一个协程任务，确实一个Task也不会有大量的切出切入操作，大多数都是1-2次。所以很多场合还是比较适合的。所以才有了实现这个共享栈的想法。

带来的限制条件
------
前面说了共享栈会有一些暗坑。主要是协程的设计理念本身是对上层屏蔽RPC的细节，让异步调用看起来想同步一样。
但是一旦使用了共享栈以后，一旦协程切出，它的栈就被封存了。因为其他的协程会复用原来真实的执行栈，所以，呗切出的栈上的对象是不能访问的。
所有有一个要求是，共享栈的协程的栈上的数据，必然不能传出来到其他协程里。如果要多个协程之间传输数据的话，必须通过堆来复制数据。这样就不完全透明了。

不过大多数应用场景中多个协程互相引用数据的地方其实比较少。

libcopp实现方案和开销
------
首先，GCC动态栈会会让我无法找出实际栈的连续地址，所以如果开启了splt-segment特性的话，是不允许支持共享栈的（后面可以用gcc的内部api来去栈信息，但是感觉都用动态栈了，共享栈就没必要了）。

其实我希望是对同一种协程类型，可以选择使用共享栈还是独立分配栈。这样在协程任务管理上也不需要做出更改，并且可以使用的时候，根据不同的业务来动态选择不同的方案。

第三就是为了减少使用错误的可能，**禁止从一个共享栈协程切到另一个**。
尽可能避免使用共享栈的协程创建并启动另一个，然后强迫用户写协程排队，这样就相当于显式告诉用户你得复制数据出来，不然直接传本协程的栈对象的指针或者引用是不行滴。
并且这样实现也简单点，因为如果是两个共享栈协程切换，必须先切到第三方，才能做目标协程栈的恢复工作，不然栈复制的时候会破坏正在执行的栈的数据。


各种callee_stack_在共享栈时要允许空值，使用时赋值。jump_to的入口函数和返回后。
create时判定共享栈和COPP_MACRO_USE_SEGMENTED_STACKS的冲突


单元测试和CI
------
要提供两个版本，分别测试动态栈和共享栈，默认关闭动态栈。

压力测试
------

[1]: https://github.com/owt5008137/libcopp
[2]: https://github.com/Tencent/libco