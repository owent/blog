关于BUS通信系统的一些思考（二） {#bus}
====================

> 接上文

目录
------
[TOC]


BUS系统的设计思路
------
虽然我很不愿意再设计一套BUS系统，但是现有的一些确实都没有特别符合我的口味的。所以还是尝试设计一个出来。

### 结构设计
简单来说，我希望BUS系统可以简单、高效、稳定。

#### 节点标识
所以首先，在**节点标识**方面，类似ZeroMQ的用字符串来标识端点的做法我认为时不必要的。这点上可以参照前面两种的设计，但是32位有时候作类型分割的时候可能会不够，所以可以使用***64位标识***。其实还有一个重要的原因是64位数字可以整个存放在CPU寄存器里，可以通过一个汇编指令进行比较操作，无论性能还是可以表示的节点个数都很足够。

#### 节点间关系
第二点就是**节点间关系**，我觉得可以设计成***树形结构***，而不是像上面一样的代理节点+数据节点的结构。再考虑BUS通信一般会碰到的几种消息流转方式。

第一中情况是两个节点直连。那么节点里要**记录直连的节点表**。
```sequence
节点A->节点B:
节点B->节点A:
```

第二种是需要通过公共父节点转发。
```sequence
节点A->公共父节点:找不到直连信息，发给父节点
公共父节点->节点B:转发消息
```
这种情况又有分支，一种是接下来父节点通知两个子节点直接建立连接通道，另一种是不通知，每次都由父节点转发。如果子节点要建立直连通道则如下图所示：
```sequence
节点A->公共父节点:找不到直连信息，发给父节点
公共父节点->节点B:转发消息
公共父节点->节点A:通知节点A直连到节点B
节点A->节点B:有直连信息，直接发送
```
按照之前真实系统的设计，节点分为三层的情况下（第一层是集群管理节点；第二层为物理机代理节点；第三层是业务进程节点）。第一层节点再转发的时候会通知第二层节点之间直连，第二层也会通知第三层节点之间互联，所以这里***建议默认开启通知子节点互相直连***的通知。

这里的第二个问题在于需要转发时的消息路由。当节点需要发送消息并没有发送目标节点的信息是直接扔给父节点呢还是直接返回错误呢？这两种方式都各有利弊，如果没有目标节点就发给父节点这种方式很简单，但是问题是自身不能立刻感知是否发送成功，如果不成功需要等父节点通知，这一定是一个异步的过程；而如果采用返回错误这种方式就会导致父节点在收到节点变更的通知后要把整个路由表下发，并且这期间必然存在时延。

前一种需要**错误回执协议**（假设数据不会丢失，那么正确转发的情况下不需要回包），而且这种*错误回执是可选的*。而后一种需要**路由表同步协议**，并且节点内至少要对节点ID做索引。

所以按照这样的设计思路，节点注册到父节点时要报告给父节点自己是否需要全局路由表，并且**当父节点没有全局路由表时，子节点也不能有**（这里不符合条件时最好注册出错）。另外父节点需要维护一个有全局路由表的子节点列表。

在线上实际运行的环境里还碰到一个问题，就是***当有大量需要全局路由表的子节点注册时，只需要把最终结果广播一下***就好了。不需要每次注册上来子节点都广播通知，这样会浪费大量通信流量。这里可以拿一个定时器保护一下。

另一个问题是**节点注册消息的时延问题**，如果两个相同ID的节点出现在两个不同的地方同时注册，那么当他们传递到第一个有全局路由表的节点时可能都是合法的。要解决这个问题方式之一是选举出一个总裁决节点，但是决策这个总裁决节点也存在时延，而如果要引入[Paxos](http://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95)算法又过于复杂了。而且这个问题很容易在配置管理层解决，所以这里倾向于参考[*子网掩码*](http://zh.wikipedia.org/wiki/%E5%AD%90%E7%BD%91)的做法，**给每一个节点设置子节点范围**，注册时节点ID和其子节点可变范围都必须在范围内。比如，节点上报ID为0x1234，子节点可变范围是24位，则0x000000 *1234* **000001**到0x000000 *1234* **FFFFFF** 都是可用的子节点ID（其中0x0000001234000000是这个节点的ID）。

当然还有第三种方式，就是没有公共父节点的情况。
```sequence
节点A->A的父节点:找不到直连信息，发给父节点
A的父节点-->B的父节点:任何方式都可能
B的父节点->节点B:直接转给节点B
```
这种情况可以简单暴力了，每次有消息都转给父节点就好了。 

### 通信模式
接下来时通信模式。每个节点都有一个唯一ID，但是通信模式可以有很多。其中最主流的就是网络Socket。BUS系统应该设计成容易拓展或者拆除某些通信模式，所以通信模式必须抽象出来。

另外一点，就是希望BUS系统里，节点的接收端只有一个。这样可以做到地址收敛，简化通信模型。

#### 通信连接的建立
当有多种连接方式的时候，问题之一就是两个节点间应该以什么连接方式互联。

再拿之前的共享内存的例子来说，进程节点只有共享内存通道一种，但是代理节点有socket和共享内存通道两种。节点再注册时，怎么连接到父节点的通信通道和自身的接收通道是子节点决定的。如果我们把通道按优先级分化，假设网络Socket的优先级是3，Unix Socket的优先级是2，共享内存的优先级是1。那么子节点到父节点的通道优先级优先级高的一方连接低一方或者相等的一方一定是通的（当然是不出现故障的情况下）。


双方都是高优先级时：
```sequence
节点B->父节点:共享内存，优先级1（通路）
父节点->节点A:共享内存，优先级1（通路）
节点B->节点A:共享内存，优先级1（通路）
```
一方是高优先级时：
```sequence
节点B->父节点:共享内存，优先级1（通路）
父节点->节点A:网络Socket，优先级3（通路）
节点B->节点A:网络Socket，优先级3（通路）
```
```sequence
节点B->父节点:网络Socket，优先级3（通路）
父节点->节点A:共享内存，优先级1（通路）
节点B->节点A:网络Socket，优先级3（如果节点A有网络Socket接收通道，通路）
节点B-->节点A:共享内存，优先级1（不一定通）
```
双方是低优先级时：
```sequence
节点B->父节点:网络Socket，优先级3（通路）
父节点->节点A:网络Socket，优先级3（通路）
节点B->节点A:网络Socket，优先级3（通路）
节点B-->节点A:共享内存，优先级1（如果节点A有共享内存通道，不一定通）
```

所以**子节点上报时还要通知兄弟节点接入的允许的通道类型**。同样，*如果没有允许的连接通道，则父节点也不需要再发兄弟节点直连通知*。

#### 网络Socket
网络Socket就很简单，因为本来就是面向连接的。加一下断线重联什么的就好了。然后linux下加个epoll、windows下加个iocp、其他什么系统价格kqueue什么的就好了。

#### Unix Socket
这玩意纯属IPC用得，操作和网络Socket一样，不能跨机器通信。

#### 共享内存
使用共享内存最大的困难就是前面的收敛接收端点的需求。对于socket而言，因为一定是面向连接的一对一的所以比较好说。而共享内存要收敛接收端就必须实现至少**多写单读**的共享内存通道。

> Written with [StackEdit](https://stackedit.io/).


